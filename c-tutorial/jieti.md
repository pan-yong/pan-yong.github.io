## 解题方法

###### 第一步：仔细读题

遇到难题、抽象题，要一个字一个字读题。程序代码，要先通览结构，而不是掉进循环细节。要整体重复多读几遍，才能理解题意，弄清目标。

###### 第二步：从语法角度解题

- 头文件的引入、宏定义
- 函数申明
- 变量定义及**初始化**
- 函数的定义与调用

###### 第三步：深入代码逻辑解题

- 梳理代码，圈出if、for、while等语句块
- 理解代码上下文逻辑关系，明确各变量的含义与作用，从而推导出要填的关键表达式。

###### 第四步：再次仔细阅读题目和代码，确认题目目标理解正确，确认代码逻辑无误，检查答案书写规范。

## 套卷十一

###### 33. 程序填空题

（1） 链表题

（2）二维数组题

###### 34. 程序改错题

（1）字符串，指针数组，指向指针的指针

（2）字符串匹配

###### 35. 程序分析题

（1）一维数组的应用：约瑟夫环问题。

罗马人占领乔塔帕特后，39个犹太人和Josephus及他的朋友躲在一个山洞中。39个犹太人决定宁死也不被敌人抓到，于是决定集体自杀。大家经过讨论决定了一种自杀方式，41个人围成一个圆圈，由第1个人开始报数，每报数到3的人就必须自杀，然后再由下一个人重新开始报数，直到所有人都自杀为止。然而，约瑟夫和他的朋友并不想遵从，Josephus要他的朋友先假装同意该方案，然后将他朋友和自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。那么，为什么约瑟夫将自己和朋友排在第16与第31的位置就可逃过该死亡游戏呢？

<img src="C:\Users\py\AppData\Roaming\Typora\typora-user-images\image-20210427161029714.png" alt="image-20210427161029714" style="zoom:25%;" />

```c
#include<stdio.h>
#define N 41
#define M 3
int main()
{
    _____________________;
    int count = 1, i = 0, pos = -1, alive;
    while(count <= N)
    {
        do{
            pos = (pos+1)%N;
            if(man[pos] == 0)
                ____________;
            if(i==M){
                i = 0;
                ____________;
            }
        }while(1);
        man[pos] = count;
        _________________;
    }
    scanf("%d", &alive);
    for(i = 0; i < N; i++){
        if(man[i]>=___________)
            printf("%d : %d\n", i+1, man[i]);
    }
}
```

## 金币

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 N天每天收到 N 枚金币后，骑士会在之后的连续 N+1天里，每天收到 N+1枚金币。请计算在前 K 天里，骑士一共获得了多少金币。（NOIP 2015 普及组）

```c
int main()
{
    int sum = 1, k, t, n, j;
    scanf("%d", &k);           // 输入k天
    for(t = 1; ;t++)
    {
        n = __________________;
        if(n + t + 1 >= k)
            _____________;
    }
    n = k - n;
    for(j = 2; j <= t; j++)
        sum = ______________;
    sum = _______________;
    printf("%d", _________);  // 输出骑士一共获得的金币数
    return 0;
}
```

