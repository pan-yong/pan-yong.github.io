##### 实战

###### 合并有序数组

https://leetcode-cn.com/problems/merge-sorted-array/

```c
// 算法思路：把nums2数组，一个一个插入排序到nums1数组中。
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    int i, j;
    for(i = 0; i < n; i++)
    {
        j = m - 1;
        while(j >= 0 && nums1[j] > nums2[i])
        {
            nums1[j+1] = nums1[j];
            j--;
        }
        nums1[j+1] = nums2[i];
        m++;
    }
}
```

官方方法一：直接合并后排序

```c
int cmp(int *p1, int *p2)
{
    return *p1 - *p2;
}
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    int i;
    for(i = 0; i < n; i++)
        nums1[m+i] = nums2[i];
    qsort(nums1,m+n,sizeof(int),cmp);
}
```

官方方法二：双指针

<img src=".\images\1.gif" alt="1" style="zoom:50%;" />

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    int *temp = (int *)malloc(sizeof(int)*nums1Size);
    int i = 0, j = 0, k = 0;
    while(i < m && j < n)
    {
        if(nums1[i] < nums2[j])
            temp[k++] = nums1[i++];
        else
            temp[k++] = nums2[j++];
    }
    while(i < m) temp[k++] = nums1[i++];
    while(j < n) temp[k++] = nums2[j++];
    for(i = 0; i < k; i++)
        nums1[i] = temp[i];
    free(temp);
}
```

官方方法三：逆向双指针

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
    int *p = nums1 + m - 1;
    int *q = nums2 + n - 1;
    int *r = nums1 + nums1Size - 1;
    while(p >= nums1 && q >= nums2)
    {
        if(*p > *q)
            *r-- = *p--;
        else
            *r-- = *q--;
    }
    while(p >= nums1) *r-- = *p--;
    while(q >= nums2) *r-
}
```

